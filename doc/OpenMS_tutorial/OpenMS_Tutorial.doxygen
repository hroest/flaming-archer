// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

// Attention:
// - prefix the tutorial pages with 'TOPP_'
// - to add new pages you have to add them to:
//    - doc/OpenMS_tutorial/refman_overwrite.tex (pdf output)
//    - doc/doxygen/public/OpenMS_Tutorial_html.doxygen (html output)

//####################################### TERMS #######################################

/**

@page tutorial_ms_terms Mass spectrometry terms

 The following terms for MS-related data are used in this tutorial and the %OpenMS class documentation:
 - raw data point @n
   An unprocessed data point as measured by the instrument.
 - peak @n
   Data point that is the result of some kind of peak detection algorithm. 
   Peaks are often referred to as @a sticks or @a centroided @a data as well.
 - spectrum / scan @n
   A mass spectrum containing raw data points (<i>raw spectrum</i>) or peaks (<i>peak spectrum</i>).

  @image html Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" 
  @image latex Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" width=10cm

 - map @n
   A collection of spectra generated by a HPLC-MS experiment. Depending on what kind of
   spectra are contained, we use the terms  <i>raw map</i> or <i>peak map</i>.
 - feature @n
   A chemical entity detected in an HPLC-MS experiment, typically a peptide.

  @image html Terms_Map.png "Peak map with a marked feature (red)" 
  @image latex Terms_Map.png "Peak map with a marked feature (red)" width=10cm
  
*/

//####################################### CONCEPT #######################################

/**

@page tutorial_concept OpenMS concepts
  
  This chapter covers some very basic concepts needed to understand %OpenMS code.
  It describes %OpenMS primitive types, namespaces, exceptions and
  important preprocessor macros. The classes described in this section can be found in the @a CONCEPT folder.
  
@section concept_primitives Basic data types

  %OpenMS has its own names for the C++ primitive types. The integer types of %OpenMS
  are @a Int (int) and @a UInt (unsigned int). For floating point numbers @a Real (float) and
  @a DoubleReal (double) are used.

  These and more types are defined in @a OpenMS/CONCEPT/Types.h.

@section concept_namespace The OpenMS namespace

  The main classes of %OpenMS are implemented in the namespace @a OpenMS. There are several
  sub-namespaces to the @a OpenMS namespace. The most important ones are:
  - @a OpenMS::Internal contains auxiliary classes that are typically used by only a few classes.
  - @a OpenMS::Constants contains nature constants.
  - @a OpenMS::Math contains math functions and classes.
  - @a OpenMS::Exception contains the %OpenMS exceptions.
  
  There are several more namespaces. For a detailed description have a look at the
  class documentation.

@section concept_exceptions Exception handling in OpenMS

  All exceptions are defined in the namespace @a OpenMS::Exception. The Base class for all
  %OpenMS exceptions is @a Base. This base class provides three members, which facilitate
  debugging %OpenMS exceptions. It stores the source file, the line number and the function
  name where the exception occurred. All derived exceptions provide a constructor that takes
  at least these arguments. The following code snippet shows the handling of an index overflow: 
  @code
    void someMethode(UInt index) throw (Exception::IndexOverflow)
    {
      if (index >= size())
      {
        throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, index, size()-1);
      }
      // do something
    };
  @endcode
  @a __FILE__ and @a __LINE__ are built-in preprocessor macros that hold the file name and line number.
  @a __PRETTY_FUNCTION__ is replaced by the GNU G++ compiler with the demangled name of 
  the current function. For other compilers it is defined as "<unknown>". The last two arguments
  are the invalid index and the maximum allowed index.

  The file name, line number and function name are very useful when debugging. However, %OpenMS
  also implements its own exception handler which allows to turn each uncaught exception into a 
  segmentation fault. The mechanism allows developers to trace the source of an exception
  with a debugger. The only thing you have to do to use it is to set the environment variable
  @a OPENMS_DUMP_CORE.

@section concept_macros Condition macros
  
  In order to enforce invariants, the two preprocessor macros @a OPENMS_PRECONDITION and
  @a OPENMS_POSTCONDITION are provided. These macros are enabled if debug info is enabled 
  and optimization is disabled in @a configure. Otherwise they are removed by the preprocessor,
  so they won't cost any performance.

  The macros throw Exception::Precondition or Exception::Postcondition respectively if 
  the condition fails. The example from section @ref concept_exceptions could have been 
  implemented like that:
  @code
    void someMethode(UInt index)
    {
      OPENMS_PRECONDITION(index < size(),"Precondition not met!");
      //do something
    };
  @endcode

*/

//####################################### DATASTRUCTURES #######################################

/**

@page tutorial_datastructures Auxiliary datastructures
  
  This section contains a short introduction to three datastructures you will
  definitely need when programming with %OpenMS. The datastructures module of the
  class documentation contains many more classes, which are not mentioned here in
  detail. The classes described in this section can be found in the @a DATASTRUCTURES folder.

@section datastructures_string The OpenMS string implementation

  The %OpenMS string implementation @a OpenMS::String is based on the Qt string @a QString.
  In order to make the %OpenMS string class more convenient, some methods have been
  implemented in addition to the QString methods.

  There is one property @a String inherits form @a QString that you should know about. 
  QString uses implicit sharing (copy-on-write), i.e. two copies of QString with
  the same content point to the same character array as long as you do not modify 
  one of the strings. This behavior allows to use pass-by-value instead of 
  pass-by-reference without loosing performance. A list of all Qt classes that use
  implicit sharing can be found in the Qt reference manual.

  @note There are many more %OpenMS classes that are based on Qt classes, e.g. @a Data,
  @a DateTime and @a DataValue. Making yourself familiar with these Qt classes would be
  no harm!

@section datastructures_dposition D-dimensional coordinates

  Many %OpenMS classes, especially the kernel classes, need to store some kind of 
  d-dimensional coordinates. The template class @a DPosition is used for that purpose.
  The interface of DPosition is pretty straight forward. The operator[] is used to
  access the coordinate of the different dimensions. The dimensionality is stored
  in the enum value @a DIMENSION. The following example (Tutorial_DPosition.C) 
  shows how to print a DPosition to the standard output stream.
  
  First we need to include the header file for @a DPosition and @a iostream. Then we
  import all the %OpenMS symbols to the scope with the @a using directive.
  @dontinclude Tutorial_DPosition.C
  @until namespace
  The first commands in the main method initialize a 2-dimensional @a DPosition :
  @until 47.11
  Finally we, print the content of the DPosition to the standard output stream:
  @until main
  
  The output of our first little %OpenMS program is the following:
  @code
    Dimension 0: 8.15
    Dimension 1: 47.11
  @endcode
  
@section datastructures_drange D-dimensional ranges
  
  Another important datastructure we need to look at in detail is @a DRange. 
  It defines a d-dimensional, half-open interval through its two @a DPosition members.
  These members are accessed by the @a min and @a max methods and can be
  set by the @a setMin and @a setMax methods.

  DRange maintains the invariant that @a min is geometrically less or equal to @a max,
  i.e. @f$ min()[x] <= max()[x]' @f$. The following example (Tutorial_DRange.C) demonstrates this behavior.

  This time we skip everything before the main method. In the main method we 
  create a range and assign values to @a min and @a max. Note that the the minimum
  value of the first dimension is larger than the maximum value.
  @dontinclude Tutorial_DRange.C
  @skip main
  @until setMax
  Then we print the content of @a range :
  @until main  
  
  The output is:
  @code
    min 0: 1
    max 0: 1
    min 1: 3
    max 1: 5
  @endcode
  As you can see, the minimum value of dimension one was adjusted in order
  to make the maximum of @a 1 conform with the invariant.

  @a DIntervalBase is the closed interval counterpart (and base class) of @a DRange.
  Another class derived from @a DIntervalBase is @a DBoundingBox. It also represents a
  closed interval, but differs in the methods. Please have a look at the class 
  documentation for details!

*/

//####################################### KERNEL #######################################

/**

@page tutorial_kernel The kernel classes
 
 The %OpenMS kernel contains the datastructures that store the actual MS data, i.e. 
 raw data points, peaks, features, spectra, maps.
 The classes described in this section can be found in the @a KERNEL folder.

@section kernel_datapoints Raw data point, Peak, Feature, ...
  
  In general there are three types of data points: raw data points, peaks and picked peaks.
  Raw data points provide members to store position (mass-to-charge ratio, retention time, ...) and intensity.
  Peaks are derived form raw data points and add an interface to store meta information. 
  Picked peaks are derived from peaks and have additional members for peak shape information: 
  charge, width, signal-to-noise ratio and many more.
  
  The kernel data points exist in three versions: one-dimensional, two-dimensional and d-dimensional.

  @image html Kernel_DataPoints.png "Data structures for MS data points" 
  @image latex Kernel_DataPoints.png "Data structures for MS data points" width=14cm 

  @par one-dimensional data points
  The one-dimensional data points are most important, the two-dimensional and d-dimensional data points
  are needed rarely.
  The base class of the one-dimensional data points is @a RawDataPoint1D. It provides
  members to store the mass-to-charge ratio (@a getMZ and @a setMZ) and the intensity
  (@a getIntensity and @a setIntensity). @n
  @a Peak1D is derived from @a RawDataPoint1D and adds a interface for metadata (see @ref metadata_metainfo). @n
  @a PickedPeak1D is derived from @a Peak1D and adds information about the peak shape.

  @par two-dimensional data points
  The two-dimensional data points are needed when geometry algorithms are applied
  to the data points. A special case is the @a Feature class, which needs a two-dimensional
  position (m/z and RT). @n
  The base class of the two-dimensional data points is @a RawDataPoint2D. It provides
  the same interface as @a RawDataPoint1D and additional members for the retention time (@a getRT and @a setRT). @n
  @a Peak2D is derived from @a RawDataPoint2D and adds a interface form metadata. @n
  @a Feature is derived from @a Peak2D and adds information about the border of the feature, fitting quality
  and so on.
  
  @par d-dimensional data points
  The d-dimensional data points are needed only in special cases, e.g. in template classes that
  must operate on any number of dimensions. @n
  The base class of the d-dimensional data points is @a DRawDataPoint. The methods to access the position
  are @a getPosition and @a setPosition. @n
  Note that the one-dimensional and two-dimensional data points also have the methods 
  @a getPosition and @a setPosition. They are needed to able to write algorithms that can operate on 
  all data point types. It is however recommended not to use these members unless you really write such
  a generic algorithm.

@section kernel_spectra Spectra
  
  @par one-dimensional spectrum
  The most important container for raw data and peaks is @a MSSpectrum. It is a template
  class that takes the peak type as template argument. The default peak type is @a Peak1D. Possible other peak types
  are classes derived from @a RawDataPoint1D of classes providing the same interface. @n
  @a MSSpectrum is derived from two base classes: @a DSpectrum, a generic container for d-dimensional peak data, and from
  @a SpectrumSettings, a container for the meta data of a spectrum. Here MS data handling is explained, 
  @a SpectrumSettings is described in section @ref metadata_spectrum.

  @par d-dimensional spectrum
  The base class of @a MSSpectrum is @a DSpectrum. This class provides a generic container for d-dimensional data.
  One of the template arguments of @a DSpectrum is the Container the data is stored in. As container @p DPeakArray or a 
  container with the same interface is used. @a DPeakArray is vector of data points with a more convenient interface 
  for sorting of the data. @n
  The peak container can be accessed through the @a getContainer() method. For convenience, part of the container interface is
  also provided by @a DSpectrum.

  In the following example (Tutorial_MSSpectrum.C) program, a @a MSSpectrum is filled with peaks, sorted according to mass-to-charge
  ratio and a selection of peak positions is displayed.

  First we create a spectrum and insert peaks with descending mass-to-charge ratios: 
  @dontinclude Tutorial_MSSpectrum.C
  @skip main
  @until }
  Then we sort the peaks in according to ascending mass-to-charge ratio. As the method used for sorting is not wrapped by
  @a DSpectrum, we need to access the container to sort it.
  @until sort 
  Finally we print the peak positions of those peaks between 800 and 1000 Thomson. For printing all the peaks in the
  spectrum, we simply would have used the STL-conform methods @a begin() and @a end(). 
  @until main
  
  @par Typedefs
  For convenience the following type definitions are defined in @a OpenMS/KERNEL/StandardTypes.h.
  @code
  typedef MSSpectrum<Peak1D> PeakSpectrum;
  typedef MSSpectrum<RawDataPoint1D> RawSpectrum; 
  @endcode  

@section kernel_maps Maps 
  
  Although raw data maps, peak maps and feature maps are conceptually very similar. They are stored in different
  data types. For raw data and peak maps, the default container is @a MSExperiment, which is an array of @a MSSpectrum
  instances. Just as @a MSSpectrum it is a template class with the peak type as template parameter.

  In contrast the to raw data and peak maps, feature maps are no collection of one-dimensional spectra, but a set
  of two-dimensional @a Feature instances. The main datastructure for feature maps is called @a FeatureMap.

  Although @a MSExperiment and @a FeatureMap differ in the data they store, they also have things in common.
  Both stores meta data that is valid for the whole map, i.e. sample description and instrument description.
  This data is stored in the common base class @a ExperimentalSettings.

  @par MSExperiment
  The following figure shows the big picture of the kernel datastructures. @a MSExperiment is
  derived from @a ExperimentalSettings (meta data of the experiment) and from @a vector<MSSpectrum>.
  The one-dimensional spectrum @a MSSpectrum is derived from SpectrumSettings (meta data of a spectrum)
  and from @a DSpectrum<1>, which stores the actual peak data in a @a DPeakArray. @n
  Since DPeakArray is can store all types of peaks derived from @a RawDataPoint, all the data containers
  are template classes, that take the peak type as template argument. This is omitted in the diagram for
  simplicity.

  @image html Kernel.png "Overview of the main kernel datastructures" 
  @image latex Kernel.png "Overview of the main kernel datastructures" width=6cm

  @par Typedefs
  For convenience the following map types are defined in @a OpenMS/KERNEL/StandardTypes.h.
  @code
  typedef MSExperiment<Peak1D> PeakMap;
  typedef MSExperiment<RawDataPoint1D> RawMap; 
  @endcode

  The following example program (Tutorial_MSExperiment.C), creates a @a MSExperiment containing four @a MSSpectrum instances.
  Then it iterates over an area and prints the peak positions in the area:

  First we create the spectra in a for-loop and set the retention time and MS level. Survey scans have 
  a MS level of 1, MS/MS scans would have a MS level of 2, and so on.
  @dontinclude Tutorial_MSExperiment.C
  @skip main
  @until setMSLevel
  Then we fill each spectrum with several peaks. As all spectra would have the same peaks otherwise,
  we add the retention time to the mass-to-charge ratio of each peak.
  @until creation
  Finally we iterate over the RT range (2,3) and the m/z range (603,802) and print the peak positions.
  @until }
  The output of this loop is:
  @code
  2 - 702
  2 - 802
  3 - 603
  3 - 703
  @endcode
  For printing all the peaks in the experiment, we could have used the STL-iterators of the 
  experiment to iterate over the spectra and the STL-iterators of the spectra to iterate over the peaks:
  @until main

  @par FeatureMap
  @a FeatureMap, the container for features, is simply a @a vector<Feature>. Additionally, it is 
  derived from @a ExperimentalSettings, to store the meta information. Just like @a MSExperiment
  it is a template class. It takes the feature type as template argument.
  
  The following example (Tutorial_FeatureMap.C) shows how to insert two features into a map and iterate over the features.
  @dontinclude Tutorial_FeatureMap.C
  @skip main
  @until end of main
  
  @par RangeManager  
  All peak and feature containers (@a DSpectrum, @a MSExperiment, @a FeatureMap) are also derived from @a RangeManager.
  This class facilitates the handling of MS data ranges. It allows to calculate and store both the position range 
  and the intensity range of the container.
  
  The following example (Tutorial_RangeManager.C) shows the functionality of the class @a RangeManger using a @a FeatureMap.
  First a @a FeatureMap with two features is created, then the ranges are calulated and printed:
  @dontinclude Tutorial_RangeManager.C
  @skip main
  @until end of main
  
  The output of this program is:
  @code
  Int: 461.3 - 12213.5
  RT:  15 - 23.3
  m/z: 571.3 - 1311.3
  @endcode
  
*/

//####################################### METADATA #######################################

/**

@page tutorial_metadata How meta data is stored

  The meta information about an HPLC-MS experiment are stored in @a ExperimentalSettings and
  @a SpectrumSettings. All information that is not covered by these classes can be stored
  in the type-name-value datastructure @a MetaInfo. All classes described in this section
  can be found in the @a METADATA folder.
  
@section metadata_metainfo MetaInfo

  MetaInfo is used to easily store information of any type, that does not fit into the the other
  classes. It implements type-name-value triplets.

  @a DataValue is a data structure that can store any numerical
  or string information. It also supports casting of the stored
  value back to its original type.

  @a MetaInfo is a associative container that stores
  @a DataValue instances as values associated to string keys.
  Internally a the string keys are converted to integer keys for
  performance resaons i.e. a @a map<UInt,DataValue> is used.
  
  The @a MetaInfoRegistry associates the string keys used in
  @a MetaValue with the integer values that are used for
  internal storage. Each key used has to be registered at the
  registry first. The @a MetaInfoRegistry is a singleton.

  If you want a class to have a @a MetaInfo member, simply derive it from @a MetaInfoInterface.
  This class provides a @a MetaInfo member and the interface to access it.

  @image html MetaInfo.png "The classes involved in meta information storage" 
  @image latex MetaInfo.png "The classes involved in meta information storage" width=5cm
  
  The folowing example (Tutorial_MetaData.C) shows how to use @a Metadata.
  First we must register the names we want to use, then we can set the values:
  @dontinclude Tutorial_MetaInfo.C
  @skip main
  @until Unique identifier
  In order to access the values we can either use the registered name or the index of the name.
  The @a getMetaValue method returns a @a DataValue, which has to be casted to the right type.
  If you do not know the type, you can use the @a DataValue::valueType() method.
  @until end of main
  
@section metadata_experiment Meta data of a map

  This class holds meta information about the experiment that is valid for the whole experiment:
  - protein identifications of ID engines
  - preprocessing performed on the data
  - MS instrument
  - source file
  - contact person
  - sample description
  - instrument software
  - HPLC settings

  @image html ExperimentalSettings.png "Map meta information" 
  @image latex ExperimentalSettings.png "Map meta information" width=10cm
  
@section metadata_spectrum Meta data of a spectrum

  This class contains meta information about settings specific to one spectrum:
  - spectrum-specific instrument settings
  - peptide and protein identifications of ID engines
  - precursor information (of MS/MS spectra)
  - description of the @a MetaInfo present for each data point
  - information on the acquisition

  @image html SpectrumSettings.png "Spectrum meta information" 
  @image latex SpectrumSettings.png "Spectrum meta information" width=7cm

*/

//####################################### FORMAT #######################################

/**

@page tutorial_format File and DB access
  
  All classes for file and database IO can be found in the @a FORMAT folder.
 
@section format_file File adapter classes

  The interface of most file adapter classes is very similar. They implement
  a @a load and a @a store method, that take a file name and the appropriate
  data structure.

  The following example (Tutorial_FileIO.C) demonstrates the use of @a MzDataFile
  and @a MzXMLFile to convert one format into another using @a MSExperiment to hold the temporary data:
  @dontinclude Tutorial_FileIO.C
  @skip main
  @until end of main

  @par FileHandler
  In order to make the handling of different file types easier, the class
  @a FileHandler can be used. It loads a file into the appropriate
  datastructure independent of the file type. The file type is determined
  from the file extention or the file contents:
  @code
  MSExperiment<> in;
  FileHandler handler();
  handler.loadExperiment("input.mzData",in);
  @endcode

@section format_db DB access
  
  For database access, the class @a DBAdapter is used. As its interface is very similar
  to the interface of the file adapters, no example is shown here.

@section format_options PeakFileOptions
  
  In order to have more control over loading data from files or databases,
  most adapters can be configured using @a PeakFileOptions. The following options 
  are available:
  - only a specific retention time range is loaded
  - only a specific mass-to.charge ratio range is loaded
  - only a specific intensity range is loaded
  - only spectra with a given MS level are loaded
  - only meta data of the whole experiment is loaded (@a ExperimentalSettings)

@section format_param Param 
  
  Most algorithms of %OpenMS and some of the TOPP tools have many parameters. The parameters
  are stored in instances of @a Param. This class is a extension of Windows INI files.
  The actual parameters (type, name and value) are stored in sections. Sections can contain parameters
  and sub-sections, which leads to a tree-like structure. The values are stored in @a DataValue, but 
  @a Param supports only the types @a string, @a int and @a float. @n
  Parameter names are given as a string including the sections and subsections in which ':' is used as a delimiter. 
  
  The following example shows how a file description is given.
  @dontinclude Tutorial_Param.C
  @skip main
  @until end of main
*/

//####################################### TRANSFORMATION #######################################

/**

@page tutorial_transformations Data reduction

Data reduction in LC-MS analysis mostly consists of two steps. In the first step, 
called "peak picking", important information of the mass spectrometric peaks
(e.g. peaks' mass centroid positions, their areas under curve and full-width-at-half-maxima) 
 are extracted from the raw LC-MS data. 
The second data reduction step, called "feature finding", represents the quantification of all peptides in a proteomic sample.
Therefore the signals in a LC-MS map caused by all charge and isotopic variants of the peptide are detected and summarized resulting
in  list of compounds or features, each characterized by mass, retention time and abundance.
 
@image html RawPeakFeatureMap.png "Part of an LC-MS map at different stages of data reduction. Axes depict retention time, m/z, and intensity. From left to right raw data points, peak  picked data points and a feature are shown." 
@image latex RawPeakFeatureMap.png "Part of an LC-MS map at different stages of data reduction. Axes depict retention time, m/z, and intensity. From left to right raw data points, peak picked data points and a feature are shown." width=10cm 


@section transformations_pp Peak picking

For peak picking the class @a PeakPickerCWT is used. Because this class detects and 
extracts mass spectrometric peaks it is applicable to LC-MS as well as MALDI raw data. 

The following example shows how to open a raw map (in mzData format), initialize a
 PeakPickerCWT object, set the most important parameters (the scale of the wavelet, 
 a peak's minimal height and fwhm), and start the peak picking process.

@dontinclude Tutorial_PeakPickerCWT.C
  @skip main
  @until end of main

The output of the program is:
 @code
		Scale of the wavelet: 0.2
		Minimal fwhm of a mass spectrometric peak: 0.1
		Minimal intensity of a mass spectrometric peak 500

		Number of picked peaks 14
@endcode




@Note A rough standard value for the peak's scale is the average fwhm of a mass
spectrometric peak.  

@section transformations_ff Peptide Quantification

The FeatureFinder implements an algorithms for the detection and
quantification of peptides from LC-MS maps. In constrast to the
previous step (peak picking) we do not only search for pronounced
signals (peak) in the LC-MS map but search explicitly for peptides
which can be recognized by their isotopic pattern.

This approach is based on work published on Groepl et al. (2005) and 
Schulz-Trieglaff et al. (2007). Essentially, we use wavelet-based
pattern matching to extract isotopic pattern from single scans and
join adjacent pattern using a geometric approach. We filter the
extracted signals by matching them against a averagine model.

There are two possibilities to use the feature finding
algorithms. The first and easiest one is to use the corresponding
TOPP (TOPP = The OpenMS Proteomics Pipeline) module. It is a 
commandline program that offers an online help and is pretty 
self-explanatory.

The second possibility, for the more advanced user who might even
want to implement his or her own modules, is to use OpenMS as a
library and write an FeatureFinder application of your own. This
is straightforward to do. A short example is given below:

@code

MzXMLFile mzxml_file;
MSExperimentExtern< > exp;

mzxml_file.load("path_to_rawdata_file",exp);

FeatureFinder ff;
ff.setData(exp);
FeatureMap< > features = ff.run();
FeatureMapFile().store(features);

@endcode

This small program loads a data set from a mzXML file, loads this
data into the FeatureFinder class and runs the algorithm. The
resulting features are stored in an instance of class FeatureMap
which is a simple container for features. The feature map can be
stored or used for further processing.

*/

//####################################### FILTERING #######################################

/**

@page tutorial_filtering Signal processing
 
 
@section filtering_baseline Baseline filters

@section filtering_smoothing Smoothing filters

*/

//####################################### CHEMISTRY #######################################

/**

@page tutorial_chemistry Chemistry

@section Elements

There is a representation of Elements implemented in %OpenMS. The correcsponding class is named Element. This class stores the relevant information about an element. The handling of the Elements are done by the class ElementDB, which is implemented as an singleton. This means there is only one instance of the class in %OpenMS. This is straightforward because the Elements do not change during execution. The data stored in an Element spans its name, symbol, atomic weight, and isotope distribution beside others. 
// example

@section EmpiricalFormula

The Elements described in the section above can be combined to empirical formulas. Application are the exact weights of molecules, like peptides and their isotopic distributions. The class support a large number of operations like addition and substraction. 
// example
// isodist example

@section Residue

A residue is represented in %OpenMS by the class Residue. It provides a container for the amino acids as well as some functionality. The class is able to provide information such as the isotope distribution of the residue, the average and monoisotopic weight. The residue can be identified by their full name, their three letter abbreviation or the single letter abreviation. The residue can also be modified, which is implemented in the Modification class. Additional less frequently used parameters of a residue like the gas-phase basicity are also availble.

@section AASequence
This class handles the amino acid sequences in %OpenMS. A string of amino acid residues can be turned into a instance of AASequence to provide some commonly used operations and data. The implementation supports mathmatical operatotions like addition or substraction. Also, average and mono isotopic weight and isotope distributions are accessable. 

%OpenMS handles mass spectrometry data all the weigths formulas and isotope distribution can be calculated depending on the charge state (additional proton count in case of positive ions) and ion type. Therefore the class allows for a flexible handling of amino acid strings.

@section TheoreticalSpectrumGenerator

This class implements a simple generator to generate tandem MS spectra from a given peptide charge combination. There are various options which influence the occuring ions and their intensities.

*/


//####################################### ANALYSIS #######################################

/**

@page tutorial_analysis High level data analysis
 
 
@section analysis_mapmapping Map mapping

@section analysis_id Identification

*/

//####################################### HOWTO #######################################

/**

@page tutorial_howto HowTo
 
@section howto_algorithm Creating a new algorithm

Most of the algorithms in %OpenMS share the following base classes:
- @a ProgressLogger is used to report the progress of the algorithm.
- @a DefaultParamHandler is used to make the handling of parameters (and their defaults) easy. @n 
  In most cases you will not even need accessors for single parameters.

The interfaces of an algorithm depend on the datastructures it works on. 
For an algorithm that work on peak data, a non-template class should be used that provides templates methods operating 
on @a MSExperiment or @a MSSpectrum, no matter what peak type is used. 
See @a PeakPickerCWT for an example.

For algorithms that do not work on peak data, templates should be avoided.

*/
