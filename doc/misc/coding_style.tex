% -*- Mode: latex; tab-width: 2; -*-
% vi: set ts=2:

\documentclass[a4]{article}
\usepackage{a4wide}

%\usepackage{times}% replaces typewriter with courier - but cm typewriter is nicer
\def\rmdefault{ppl}% replaces roman fonts with postscript times font

\title{OpenMS coding conventions}
\date{$ $Rev$ $}
\author{}

\errorcontextlines100

\newtheorem{example}{Example}

\begin{document}
\maketitle

\section{Formatting}

{\bf All OpenMS files use a tab width of two.} Use the command {\tt set tabstop=2} in
{\tt vi} or {\tt set-variable tab-width 2} if you are using {\tt emacs}. For
those two editors, the indentation behavior should be set automatically
throught the standard file headers (see below).

Due to these ugly issues with setting the tabwidth in the editor, it is
perfectly ok not to use tabs at all.  In emacs, you can replace all tabs with
the right number of spaces by typing the following keys: \texttt{C-x h} (to
mark the whole buffer), then \texttt{M-x untabify RET}.

All lines are terminated UNIX-type by a LF character.  If you have
accidentally inserted CRLF or CR line endings when edting on a Windows or Mac
system, you can fix that later on with the \verb|dos2unix| command.  Using a
consistent style for line endings is important to make commands like
\verb|svn praise| helpful.

Matching pairs of opening and closing curly braces should be set to the same
column:
\begin{verbatim}
while (continue == true)
{
  for (int i = 0; i < 10; i++)
  {
    ...
  }

  if (x < 7)
  {
    ....
  }
}
\end{verbatim}
The main reason for this rule is to avoid constructions like:

\begin{verbatim}
if (isValid(a))
  return 0;
\end{verbatim}

which might later be changed to something like

\begin{verbatim}
if (isValid(a))
  error = 0;
  return 0;
\end{verbatim}

The resulting errors are hard to find. There are two ways to avoid these
problems: (a) always use braces around a block (b) write everyting in a single
line. We recommend method (a).
However, this is mainly a question of personal style, so no explicit checking
is performed to enforce this rule.

\subsection{Method declarations}
OpenMS uses some tools to validate that all declared methods are tested.
These tools require that the method declarations are formatted in a specific
way:
\begin{itemize}
	\item All method arguments must be listed in one line. Spreading them over serveral lines is not permitted.
	\item No semicolons after method implementations in a header are permitted although they are syntactiacally correct.
	\item Nested class declations should not be used unless absolutely required.
\end{itemize}

\subsection{Sample .h file}

\begin{footnotesize}
\begin{verbatim}
// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
... copyright header, not shown ...
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#ifndef OPENMS_CORE_DPEAK_H
#define OPENMS_CORE_DPEAK_H

#include <OpenMS/CONCEPT/Types.h>

#include <functional>
#include <sstream>

namespace OpenMS
{
   ... the actual code goes here ...
} // namespace OpenMS

#endif // OPENMS_CORE_DPEAK_H
\end{verbatim}
\end{footnotesize}

\subsection{Sample .C file}

\begin{footnotesize}
\begin{verbatim}
// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
... copyright header, not shown ...
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#include <OpenMS/CORE/DPeak.h>

namespace OpenMS
{
   ... the actual code goes here ...
} // namespace OpenMS

\end{verbatim}
\end{footnotesize}
Every \texttt{.h} file must be accompanied by a \texttt{.C} file, even if is
just a ``dummy''.  This way a global \texttt{make} will
stumble across errors.


\section{Name spaces}

Everything is implemented in the namespace \texttt{OpenMS}.  Please refrain
from writing \texttt{using namespace OpenMS;} or similar in a context where
other libraries might be involved (that is, basically everywhere~:-).  This
applies to \texttt{.C} files as well!  For \texttt{.h} files it is strictly
forbidden.  Instead, introduce individual symbols to the scope where you need
them.  E.\,g.\ you only have to write \texttt{using OpenMS::DPeak;} once per
\texttt{.C} file, and yet this immediately gives a hint to where the symbol is
defined.\\
\\
The use of 'using namespace std;' is forbidden in all headers!!


\section{Class requirements}

Each OpenMS class has to provide the following minimal interface:
\begin{verbatim}
  /** Class documentation...
  */
  class Test
  {
    public:

    /// default constructor
    Test();

    /// copy constructor
    Test(const Test& test);

    /// destructor
    virtual ~Test();

    /// assignment operator
    Test& operator = (const Test& test)
    {
      //ALWAYS CHECK FOR SELF ASSIGMENT!
      if (this == &test) return *this;
      //...
      return *this;
    }
  };
\end{verbatim}
Note that the destructor should be a virtual function, unless you have a very
good reason why it shouldn't.  (E.g., saving a vtable pointer.)  Essentially,
the reason is that otherwise an \texttt{operator delete} invocation on a
pointer to a base class will fail badly.

\section{Accessors for members}
Accessors to protected or private members of a class are implemented as a pair
of setMember(...) and getMember() methods.
This is necessary as accessors that return references to a member cannot be wrapped with Python!\\
There is one exception to this strict rule. For members that are too large to be
read with the get-method, modified and written back with the set-method, the
get-method may return a reference to the member. {\bf But} then an additional const
get-method has to be implemented!

\section{Exception handling}

No OpenMS program should dump a core if an error occurs. Instead, it should
attempt to die as gracefully as possible. Furthermore, as OpenMS is a
framework rather than an application, it should give the programmer ways to
catch and correct errors.
The recommended procedure to handle -- even fatal -- errors is to throw an exception. Uncaught
exception will result in a call to {\tt abort} thereby terminating the
program.

All exceptions used in OpenMS are derived from \texttt{Exception::Base}
defined in \texttt{CONCEPT/Exception.h}. A default constructor should not be
implemented for these exceptions. Instead, the constructor of all derived
exceptions should have the following signature:
\begin{verbatim}
  AnyException(const char* file, int line, const char* function[, ...]);
\end{verbatim}
Additional arguments are possible but should provide default values (see
{\tt IndexOverflow} for an example).

The {\tt throw} directive for each exception should be of the form
\begin{verbatim}
  throw AnyException(__FILE__, __LINE__, __PRETTY_FUNCTION__);
\end{verbatim}
to simplify debugging.  {\tt \_\_FILE\_\_} and {\tt \_\_LINE\_\_} are standard-defined
preprocessor macros.  The symbol {\tt \_\_PRETTY\_FUNCTION\_\_} works similar to a
\verb|char*| and contains the type signature of the function as well as its
bare name, if the GNU compiler is being used.  It is \verb|#define|d to
\verb|"<unknown>"| on other platforms. {\bf Exception::Base} provides methods
({\tt getFile}, {\tt getLine}, {\tt getFunction}) that allow the localization
of the exception's cause.

\section{Iterators}

In simple looping constructs, iterators are generally preferable to indexed
access.  Prefer ``\verb|++i|'' to ``\verb|i++|'', because the preincrement operator can safe
a copy constructor.  Use \verb|const_iterators| where possible to help
avoiding unwanted side effects.

\section{Naming conventions}

\subsection{File names}
{\bf Header files and source files should be named as the classes they
contain.}
Source files end in ".C", while header files end in ".h". File names should be
capitalized exactly as the class they contain (see below). Each header/source
file should contain one class only, although exceptions are possible for
light-weight classes.


\subsection{Underscores}

Usage of underscores in names has two different meanings: A trailing ``\_'' at
the end indicates that something is protected or private to a class.  Apart
from that, different parts of a name are sometimes separated by an underscore,
and sometimes separated by capital letters.  (The details are explained below.)

Note that according to the C++ standard, names that start with an underscore
are reserved for internal purposes of the language and its standard library
(roughly speaking), so you should never use them.


\subsection{Class / type / namespace names}

\textbf{Class names and type names always start with a capital letter.}
Different parts of the name are separated by capital letters at the beginning
of the word. No underscores are allowed in type names and class names, except
for the names of protected types and classes in classes, which are suffixed by
an underscore.  The same conventions apply for \texttt{namespace}s.
\begin{example}~\\
  {\tt class Simple} (ordinary class)\\
  {\tt class SimpleThing} (ordinary class)\\
  {\tt class PDBFile} (using an abbreviation)\\
  {\tt class Buffer\_} (protected or private nested class)\\
  {\tt class ForwardIteratorTraits\_} (protected or private nested class)
\end{example}


\subsection{Variable names}

\textbf{Variable names are all lower case letters.}  Distinguished parts of
the name are separated using underscores ``{\tt \_}''. If parts of the name
are derived from common acronyms (e.g. MS) they should be in upper case.
Private or protected member variables of classes are suffixed by an
underscore.
\begin{example}~\\
  {\tt int simple;} (ordinary variable)\\
  {\tt bool is\_found;} (ordinary variable)\\
  {\tt string MS\_instrument;} (using an abbreviation)\\
  {\tt int counter\_;} (protected or private member)\\
  {\tt int persistent\_id\_;} (protected or private member)
\end{example}
No prefixing or suffixing is allowed to identify the variable type -- this
leads to completely illegible documentation and overly long variable names.


\subsection{Function names/method names}

\textbf{Function names (including class method names) always start with a
  lower case letter.}  Parts of the name are separated using capital letters
(as are types and class names).  They should be comprehensible, but as short
as possible.  The same variable names must be used in the declaration and in
the definition.  Arguments that are actually not used in the implementation of
a function have to be commented out -- this avoids compiler warnings.  The
argument of \texttt{void} functions (empty argument list) must omitted in both
the declaration and the definition.  If function arguments are pointers or
references, the pointer or reference qualifier is appended to the variable
type. It should not prefix the variable name.
\begin{example}~\\
{\tt void hello();} (ordinary function, no arguments) \\
{\tt int countPeaks(PeakArray const\& p);} (ordinary function) \\
{\tt bool ignore(string\& /* name */);} (ordinary function with an unused argument) \\
{\tt bool isAdjacentTo(Peak const * const * const \& p) const;} (an ordinary function :-) \\
{\tt bool doSomething\_(int i, string\& name);} (protected or private member function)
\end{example}


\subsection{Enums and preprocessor constants}

\textbf{Enumerated values and preprocessor constants are all upper case
  letters.}  Parts of the name are separated by underscores.
\begin{example}~\\
  {\tt \#define MYCLASS\_SUPPORTS\_MIN\_MAX 0} (preprocessor constant) \\
  {\tt enum DimensionId \{ DIM\_MZ = 0, DIM\_RT = 1 \};} (enumerated values) \\
  {\tt enum DimensionId\_ \{ MZ = 0, RT = 1 \};} (enumerated values)
\end{example}
(You should avoid using the preprocessor anyway.  Normally, \texttt{const} and
\texttt{enum} will suffice unless something very special.)

\subsection{Parameters}

Parameters in .ini files and elsewhere are named like the things they
represent.  (By a parameter we mean the \emph{keys} used in the \texttt{Param}
class.)  Typically this will be tool names, public member variables, or public class names
(e.g.\ in case of factories).

% \subsection{Quiz}

% Here is a quiz: Which are the syntactic categories of the identifiers in
% Figure~\ref{Fig:NamingConventions}, accoring to OpenMS coding conventions?  To
% test your understanding, cover the right column and guess before reading.
% \begin{figure}
%   \begin{tabular}{|l|l|}\hline
%     Some\_Thing  & \\
%     Some\_thing  & \\
%     Some\_THING  & \\
%     some\_Thing  & \\
%     some\_thing  & variable / member \\
%     some\_THING  & \\
%     SOME\_Thing  & \\
%     SOME\_thing  & \\
%     SOME\_THING  & preprocessor macro \\
%     SomeThing    & type / enum / class \\
%     SomeTHING    & \\
%     someThing    & function / method \\
%     someTHING    & \\
%     SOMEThing    & \\
%     SOMETHING    & preprocessor macro \\
%     Some\_Thing\_  & \\
%     Some\_thing\_  & \\
%     Some\_THING\_  & \\
%     some\_Thing\_  & \\
%     some\_thing\_  & private or protected: member \\
%     some\_THING\_  & \\
%     SOME\_Thing\_  & \\
%     SOME\_thing\_  & \\
%     SOME\_THING\_  & \\
%     SomeThing\_    & private or protected: type / enum / class \\
%     SomeTHING\_    & \\
%     someThing\_    & \\
%     someTHING\_    & \\
%     SOMEThing\_    & \\
%     SOMETHING\_    & \\
%     \hline
%   \end{tabular}
% \caption{Naming conventions in OpenMS.}
% \label{Fig:NamingConventions}
% \end{figure}

\section{Documentation}

\subsection{UML diagrams}
To generate UML diagrams use yEd and export the diagrams in png format. Do not
forget to save also the corresponding .yed file.


\subsection{Doxygen}
Each OpenMS class has to be documented using Doxygen. The documentation is
inserted in Doxygen format \textbf{in the header file} where the class is
defined.  Documentation includes the description of the class, of each method,
type declaration, enum declaration, each constant, and each member variable.\\
Longer pieces of documentation start with a brief description, followed
by an empty line and a detailed description. The empty line is needed to separate
the brief from the detailed description.\\
Descriptions of classes always have a \@brief section!\\
Please use the doxygen style of the following example for OpenMS:
\begin{verbatim}
/**
  @defgroup DummyClasses Dummy classes

  @brief This class contains dummy classes

  Add classes by using the '@ingroup' command.
*/

/**
  @brief Demonstration class. << REQUIRED!

  A demonstration class for teaching doxygen

  @note All classes need brief description!
  @todo Write tests of this class! (Max Mustermann)
  @ingroup DummyClasses
*/
class Test
{
  public:
    /**
      @brief An enum type.

      The documentation block cannot be put after the enum!
    */
    enum EnumType
    {
      int EVal1,     ///< Enum value 1.
      int EVal2      ///< Enum value 2.
    };

    /**
      @brief constructor.

      A more elaborate description of the constructor.
    */
    Test();

    /**
      @brief Dummy function.

      A normal member taking two arguments and returning an integer value.
      The parameter @p dummy_a is an integer.
      @param dummy_a an integer argument.
      @param dummy_s a constant character pointer.
      @see Test()
      @return The dummy results.
    */
    int dummy(int dummy_a, const char *dummy_s);

    /// Short description in one line.
    int isDummy();

    /**
      @name Group of members.

      Description of the group.
    */
    //@{
    /// Dummy 2.
    void dummy2();
    /// Dummy 3.
    void dummy3();
    //@}

  protected:
    int value;       ///< An integer value.
};
\end{verbatim}
The defgroup command indicates that a comment block contains documentation for a group of classes, files or namespaces.
This can be used to categorize classes, files or namespaces, and document those categories.
You can also use groups as members of other groups, thus building a hierarchy of groups.
Using the ingroup command a comment block of a class, file or namespace will be added to the group or groups.\\
Documentation which does not belong to a specific .C or .h file can be written into a
separate Doxygen file (with the ending .doxygen). This file will also be parsed by Doxygen.\\
Open tasks are noted in the documentation of a header or a group using the @todo command.
The ToDo list is then shown in the doxygen menu under 'related pages'. Each ToDo should be
followed by a name in parentheses to indicated who is going to handle it.\\
Doxygen is not hard to learn, have a look at the manual :-)


\subsection{Commenting code}

The code for each .C file has to be commented. Each piece of code in OpenMS
has to contain at least {\bf 5\% of comments}. The use of {\tt //} instead of
C style comments ({\tt /* */}) is recommended to avoid problems arising from
nested comments. Comments should be written in plain \textbf{english} and
describe the functionality of the next few lines.

{\tt OpenMS/doc/tools/check\_coding} can be used to check whether a header or
source file fulfils this requirement. Invoke {\tt check\_coding} with the
filename to check (or a list of files) and it will print the percentage of
comments (including Doxygen comments) for each file.


\subsection{Examples}

Instructive programming examples can be provided in the
\texttt{source/EXAMPLES} directory.


\subsection{Revision control}

\textbf{OpenMS uses the Subversion} to manage different
versions of the source files. For easier identification of the responsible person
each OpenMS file contains the \texttt{\$Maintainer{}:\$} string in the
preamble.

Examples of \texttt{.h} and \texttt{.C} files have been given above.  In
non-C++ files (Makefiles, (La)TeX-Files, etc.) the C++ comments are replaced
by the respective comment characters (e.g.\ ``\#'' for Makefiles, ``\%'' for
(La)TeX).  TeX will switch to math mode after a \texttt{\$}, but you can work
around this by writing something like
% (avoid line break here)
\mbox{\texttt{Latest SVN \$ \$Date{}:\$ \$}}
% (/avoid line break here)
if you want to use it in texts; the one here expands to
%
% Please leave these comments so that the following will be on a single line!
%
``Latest SVN $ $Date$ $''. %
%
Subversion does not turn on keyword substitution by default.  See \texttt{svn
  -h propset} and \texttt{svn -h proplist} for details.



\section{Testing}

\subsection{General}

{\bf Each OpenMS class has to provide a test program.} This test program has to check
each method of the class. The test programs reside in the directory
{\tt OpenMS/source/TEST}. To create a new test program, rename a copy of the file
{\tt Skeleton\_test.C} to the new class test name (usually {\tt
<classname>\_test.C}). The test program has to be coded using the class test
macros as described in the OpenMS online reference. Special care should be taken
to cover all special cases (e.g. what happens, if a method is called with
empty strings, negative values, zero, null pointers etc.).

Please activate the keyword substitution of '\$Id\$' for all tests with the following command:\\
{\tt svn propset svn:keywords Id <file>}.

\subsection{Suplementary files}
If a test needs suplementary files, put these files in the {\tt OpenMS/source/TEST/data/} folder.
The name of suplementary files has to begin with the name of the tested class.

\subsection{Structure of a test program}

\subsubsection{Macros to start, finish and evaluate tests}
\begin{itemize}
        \item {\tt START\_TEST(class\_name, version)} \\ Start of a class test file (initialization)
        \item {\tt END\_TEST} \\ End of a class test file (cleanup)
        \item {\tt CHECK(name)} \\ Start of a single test, e.g. for a method
        \item {\tt RESULT} \\ End of a single test
        \item {\tt STATUS(message)} \\ Shows a status message e.g.\ used to show the progress of a test preparations that take a while
        \item {\tt ABORT\_IF(condition)} \\ Skip remainder of substest if condition holds
\end{itemize}

\subsubsection{Comparison macros}
\begin{itemize}
        \item {\tt TEST\_EQUAL(a, b)}.\\ Tests if two expressions are equal
        \item {\tt TEST\_NOT\_EQUAL(a, b)}.\\ Tests if two expressions are not equal
        \item {\tt TEST\_REAL\_EQUAL(a, b)} \\ Tests if two real numbers are equal (within a margin)
        \item {\tt TEST\_STRING\_EQUAL(a, b)} \\ Tests if \texttt a and \texttt b are equal as strings
        \item {\tt PRECISION(double)} \\ Sets the margin for TEST\_REAL\_EQUAL(a, b)
        \item {\tt TEST\_EXCEPTION(exception, expression)} \\ Tests if the expression throws the exception
        \item {\tt TEST\_FILE(file, template\_file)} \\ Tests if two files are identical
\end{itemize}
Do not use methods with side-effects inside the comparison macros i.e. *(it++). The expressions
in the macro are called serveral times, so the side-effect is triggered several times as well.

\subsubsection{Temporary files}
You might want to create temporary files during the tests. The following macro
puts a temporary filename into the string argument. The file is automatically deleted
after the test.
\begin{itemize}
        \item {\tt NEW\_TMP\_FILE(string)}
\end{itemize}

\subsubsection{Tools for testing and checking your code.}
The tool {\tt check\_test} in the {\tt source/config/tools/} folder can be used to
create test skeletons for classes. It has to be built using {\tt make}.\\
\\
There are also some PHP tools for testing and more in that directory.\\
See {\tt source/config/tools/README.txt} for details!

\subsection{Testing the TOPP programs}

The abbreviation TOPP stands for \textbf{T}he \textbf{O}penMS
\textbf{P}roteomics \textbf{P}ipeline, a collection of tools based upon the
C++ classes in OpenMS.  The TOPP tools are located in \texttt{OpenMS/source/APPLICATIONS/TOPP}.

\subsubsection{Suplementary files}
If a test needs suplementary files, put these files in the same folder.
The name of suplementary files has to begin with the name of the tested tool.
All extensions but \texttt{.tmp} or \texttt{.log} are possible.

\subsubsection{Running the tests}

The tests for TOPP programs are located in \texttt{OpenMS/source/TEST/TOPP}.
The \texttt{Makefile} provides the following main targets:
\begin{itemize}
 \item \textbf{make} : Run all tests.  This invokes the \texttt{default} make target.

  Each tool has its own make target, e.g. to test \texttt{TOPPTool}
  you can run \texttt{make TOPPTool\_test}.  The test targets are listed in
  the variables \texttt{TOPP\_TOOL\_TESTS} (for each tool individually) and
  \texttt{TOPP\_PIPELINE\_TESTS} (for pipelines composed out of several
  tools).  Note that these sub-targets should be maintained by the same
  maintainers as the tools themselves!

 \item \textbf{make debug} : Run all tests in debug mode.

  Each tool test will create a couple of \texttt{.tmp} files.  Normally, these
  are deleted automatically.  You can set \texttt{DEBUG=1} to avoid this.
  \texttt{make debug} is equivalent to \texttt{make DEBUG=1 default}.  You can
  run any test in debug mode, e.g.  \texttt{make DEBUG=1 TOPPTool\_test}.

 \item \textbf{make verbose} : Run all tests in verbose mode.

  Normally, all output written to \texttt{stdout} and \texttt{stderr} by the
  tools is redirected to \texttt{/dev/null}.  You can set \texttt{VERBOSE=1}
  to avoid this.  \texttt{make verbose} is equivalent to \texttt{make
    VERBOSE=1 default}.  You can run any test in verbose mode, e.g.
  \texttt{make VERBOSE=1 TOPPTool\_test}.

 \item \textbf{make clean} : This target will remove all temporary files
  created by the tests.  You can use it to clean up after \texttt{make debug}
  or any other test.  In order to make this target effective, it is important
  that all files generated by your tests will (finally) have a suffix
  \texttt{.tmp}, \texttt{.log} (e.g.\ \texttt{TOPP.log}), or
  \texttt{.rounded\_tmp} (explained below).  Of course you can rename them
  using \texttt{\$(MV)} to achieve this.

\end{itemize}

\subsubsection{Macros for writing the tests}

The actual tests are written using (1.) macros which are defined by
\texttt{configure} in \texttt{config\_defs.mak} and (2.) some special
functions using substitution capabilities of the (GNU) make program itself.
\begin{itemize}
 \item Don't write commands like \texttt{echo}, \texttt{diff}, \texttt{mv},
  \texttt{cp}, \texttt{rm} directly -- always use their 'uppercase'
  counterparts \texttt{\$(ECHO)}, \texttt{\$(DIFF)}, \texttt{\$(MV)},
  \texttt{\$(CP)}, \texttt{\$(RM)} provided by \texttt{configure}.  Doing so is
  necessary for portability.

 \item To invoke a TOPP tool with options, use the following syntax:

  \texttt{@\$(call RUN\_PROG\_OPT,TOPPTool,options)}

  Be careful not to insert any whitespace around the arguments of
  \texttt{call}.  Depending on the \texttt{VERBOSE} settings, this macro is
  expanded in different ways by \texttt{make} program.

 \item To check whether the output of a TOPP tool is correct, use the following syntax:

  \texttt{@\$(call TEST\_FILE\_EQUAL,correct.xtn)}

  or

  \texttt{@\$(call TEST\_FILE\_EQUAL,correct.xtn,computed.tmp)}

  This will compare two files using a small diff-like application called
  \texttt{NumericDiff} (explained in the next section).  In the first form,
  the 'other' file defaults to \texttt{correct.tmp}, that is, the basename of
  the second argument (\texttt{correct.xtn}) extended by \texttt{.tmp}.  Be
  careful not to insert any whitespace around the arguments of \texttt{call}.
  Depending on the \texttt{DEBUG} settings, this macro is expanded in
  different ways by \texttt{make} program.

\end{itemize}

\subsubsection{Numerical inaccuracy}

The TOPP tests will be run on 32 bit and 64 bit platforms.  Therefore a purely
character-based comparison of computed and expected result files might fail
although the results are in fact numerically correct -- think of cases like
\texttt{9.999e+3} vs.\ \texttt{1.0001e+4}.  Instead we provide a small program
\texttt{NumericDiff} in \texttt{OpenMS/source/TEST/TOPP}.  This program steps
through both inputs simultaneously and classifies each position into 3
categories: \emph{numbers}, \emph{characters}, \emph{whitespace}.  Within each
line of input, numbers are compared with respect to their ratio (i.e.,
relative error), characters must match exactly (e.g.\ case is significant) and
all whitespace is considered equal.  Empty lines or lines containing only
whitespace are skipped, but extra linebreaks 'within' lines will result in error
messages.  For more details and verbosity options, see the built-in help
message and the source code.

\subsubsection{File name conventions for TOPP tests}

Each test relies on a number of files.  These file should be named \\
\verb|source/TEST/TOPP/<toolname>_<nummer>_<name>.<extension>|, where
\begin{itemize}
 \item \verb|<toolname>| has the form \verb|[A-Z][a-zA-Z]*| --- the name of
  the TOPP tool
 \item \verb|<number>| has the form \verb|[0-9]+| --- the running number of
  the test
 \item \verb|<name>| has the form \verb|[-_a-zA-Z0-9]+| --- should be a
  descriptive name (\verb|_| and \verb|-| are ok here, since \verb|<toolname>|
  and \verb|<number>| must not contain them)
 \item \verb|<extension>| --- the extension expressing the type of the data.
\end{itemize}
The data files should be as small as possible, but not totally trivial.

\subsection{Is testing really necessary?}

Yes. Testing is crucial to verify the correctness of the library -- especially when
using C++. But why has it to be {\em so} complicated, using all these macros
and stuff? One of the biggest problems when building large class frameworks is
portability. C++ compilers are strange beasts and there is not a single one
that accepts the same code as any other compiler. Since one of the main
concerns of OpenMS is portability, we have to ensure that every single line of
code compiles on all platforms. Due to the long compilation times and the
(hopefully in future) large number of different platforms, tests to verify the
correct behaviour of all classes have to be carried out automatically. This
implies a well defined interface for all tests, which is the reason for all
these strange macros. This fixed format also enforces the writing of complete
class tests. Usually a programmer writes a few lines of code to test the parts
of the code he wrote for correctness. Of the methods tested after the
introduction of the test macros, about a tenth of all functions/methods showed
severe errors or after thorough testing. Most of these errors didn't occur an
all platforms or didn't show up on trivial input.

Writing tests for {\em each} method of a class also ensures that each line is
compiled. When using class templates the compiler only compiles the methods
called. Thus it is possible that a code segment contains syntactical errors
but the compiler accepts the code happily -- he simply ignores most of the
code. This is quickly discovered in a complete test of all methods. The same
is true for configuration dependend preprocessor directives that stem from
platform dependencies. Often untested code also hides inside the {\tt const}
version of a method, when there is a non-const method with the same name and
arguments (for example most of the {\tt getName}) methods in OpenMS. In most
cases, the non-const version is preferred by the compiler and it is usually
not clear to the user which version is taken. Again, explicit testing of each
single method provides help for this problem.
The ideal method to tackle the problem of untested code is the complete
coverage analysis of a class. Unfortunately this is only supported for very
few compilers, so it is not used for testing OpenMS.

One last point: writing the
test program is a wonderful opportunity to verify and complete the
documentation! Often enough implementation details are not clear at the time
the documentation is written. A lot of side effects or special cases that were
added later do not appear in the documentation. Going through the
documentation and the implementation in parallel is the best way to verify the
documentation for consistence and (strange coincidence?!) the best way to
implement a test program, too!

\end{document}
