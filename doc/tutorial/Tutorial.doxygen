// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

// Attention:
// - prefix the tutorial pages with 'tutorial_'
// - to add new pages you have to add them to:
//		- doc/tutorial/refman_overwrite.tex (pdf output)
//		- doc/doxygen/public/Tutorial_html.doxygen (html output)

//####################################### CONCEPT #######################################

/**

@page tutorial_concept OpenMS concepts
	
	This chapter covers some very basic concepts needed to understand OpenMS code.
	It describes OpenMS primitive types, namespaces, exceptions and
  important preprocessor macros.
	
@section concept_primitives Basic data types

  In OpenMS different names are used for the C++ primitive types. The integer types of OpenMS
	are 'Int' (int) and 'UInt' (unsigned int). For floating point numbers 'Real' (float) and
	'DoubleReal' (double) are used.

  These and more types are defined in 'OpenMS/CONCEPT/Types.h'.

@section concept_namespace The 'OpenMS' namespace

	The main classes of OpenMS are implemented in the namespace 'OpenMS'. There are several
	sub-namespaces to the 'OpenMS' namespace. The most important ones are:
	- 'OpenMS::Internal' contains auxilary classes that are typically used by only a few classes.
  - 'OpenMS::Constants' contains nature constants.
  - 'OpenMS::Math' contains math functions and classes.
  - 'OpenMS::Exception' contains the OpenMS exceptions.
	There are several more namespaces. For a detailed description have a look at the
  class documentation.

@section concept_exceptions Exception handling in OpenMS

  All exceptions are defined in the namespace 'OpenMS::Exception'. The Base class for all
  OpenMS exceptions is 'Base'. This base class provides three members, which facilitate
  debugging OpenMS exceptions. It stores the source file, the line number and the function
  name there the exception occured. All derived exceptions provide a constructor that takes
  at least these arguments. The following code snippet show the handling of an index overflow:	
	@code
	  void someMethode(UInt index) throw (Exception::IndexOverflow)
		{
			if (index >= size())
			{
				throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, index, size()-1);
			}
			// do something
		};
	@endcode
	'__FILE__' and '__LINE__' are built-in preprocessor macros that hold the desired information.
	'__PRETTY_FUNCTION__' is replaced by the GNU G++ compiler with the demangled name of 
	the current function. For other compilers it is defined as "<unknown>". The last two arguments
  are the invalid index and the maximum allowed index.

  The file name, line number and function name are very useful when debugging. However, OpenMS
	also implements its own exception handler which allows to turn each uncaught exception into a 
  segmentation fault. The mechanism allows developers to trace the source of an exception
  with a debugger. The only thing you have to do to use it is to set the environment variable
  'OPENMS_DUMP_CORE'.

@section concept_macros Condition macros
	
	In order to enforce invariants, the two preprocessor macros 'OPENMS_PRECONDITION' and
  'OPENMS_POSTCONDITION' are provided. These macros are enabled if debug info is enabled 
  and optimization is disabled in 'configure'. Otherwise they are removed by the preprocessor,
  so they won't cost any performance.

  The macros throw Exception::Precondition or Exception::Postcondition respectively if 
  the condition fails. The example from section @ref concept_exceptions could have been 
  implemented like that:
	@code
	  void someMethode(UInt index)
		{
			OPENMS_PRECONDITION(index < size(),"Precondition not met!");
			//do something
		};
	@endcode

*/

//####################################### DATASTRUCTURES #######################################

/**

@page tutorial_datastructures Auxilary datastructures
	
	This section contains a short introduction to three datastructures you will
  definitely need when programming with OpenMS. The datastructures module of the
  class documentation contains many more classes, which are not mentioned here in
  detail.

@section datastructures_string The OpenMS string implementation

  The OpenMS string implementation 'OpenMS::String' is based on the Qt string 'QString'.
  In order to make the OpenMS string class more convenient, some methods have been
  implemented in addition to the QString methods.

	There is one property the 'String' inherits form 'QString' that you should know about. 
  QString uses implicit sharing (copy-on-write), i.e. two copies of QString with
  the same content point to the same character array as long as you do not modify 
  one of the strings. This behaviour allows to use pass-by-value instead of 
  pass-by-reference without loosing performance. A list of all Qt classes that use
  implicit sharing can be found in the Qt refernece manual.

	@note There are many more OpenMS classes that are based on Qt classes, e.g. Data,
  DateTime and DataValue. Making yourself familiar with these Qt classes would be
  no harm!

@section datastructures_dposition d-dimensional coordinates

  Many OpenMS classes, especially the kernel classes, need to store some kind of 
  d-dimensional coordinates. The template class 'DPosition' is used for that purpose.
	The interface of DPosition is pretty steight forward. The operator[] is used to
  access the coordinate of the different dimensions. The dimensionality is stored
  in the enum value 'DIMENSION'. The following example shows how to print a DPosition
  to the standard output stream.

	First we need to include the header file for 'DPosition' and 'iostream'. Then we
  import all the OpenMS symbols to the scope with the 'using' directive.
  @dontinclude Tutorial_DPosition.C
	@until namespace
  The first commands in the main method initialize a 2-dimensional 'DPosition':
	@until 47.11
	Finally we, print the content of the DPosition to the standard output stream:
	@until main
	
	The output of our first litte OpenMS program is the following:
	@code
    Dimension 0: 8.15
    Dimension 1: 47.11
	@endcode
  
@section datastructures_drange d-dimensional coordinates
	
  Another important datastructure we need to look at in detail is 'DRange'. 
  It defines a d-dimensional, half-open interval through its two 'DPosition' members.
  These members are accessed by the 'min' and 'max' methods and can be
  set by the 'setMin' and 'setMax' methods.

  DRange maintains the invariant that 'min' is geometrically less or equal to 'max',
  i.e. 'min()[x] <= max()[x]'. The following example demonstrates this behavour.

  This time we skip everything before the main method. In the main method we 
  create a range and assign values to 'min' and 'max'. Note that the the minimum
  value of the first dimension is larger than the maximum value.
  @dontinclude Tutorial_DRange.C
	@skip main
  @until setMax
  Then we print the content of 'range':
	@until main  
  
  The output is:
	@code
    min 0: 1
    max 0: 1
    min 1: 3
    max 1: 5
	@endcode
  As you can see, the minimum value of dimension one was adjusted in order
  to make the maximum of '1' conform with the invariant.

  'DIntervalBase' is the closed interval counterpart (and base class) of 'DRange'.
  Another class derived by 'DIntervalBase' is 'DBoundingBox'. It also represents a
  closed interval, but differs in the methods. Please have a look at the class 
  documentation for details!

*/

//####################################### KERNEL #######################################

/**

@page tutorial_kernel The kernel classes
 
 The kernal data points exist in three versions: one-dimensional, two-dimensional and d-dimensioal.
 Bla bla bla ... 
 
@section kernel_peaks1D one-dimensional data points
	 
	RawDataPoint1D is the base class for bla, bla, bla
	
@section kernel_peaks2D one-dimensional data points
	
	RawDataPoint2D is the base class for bla, bla, bla

@section kernel_peaksdD d-dimensional data points

	DRawDataPoint is the base class for bla, bla, bla

*/

