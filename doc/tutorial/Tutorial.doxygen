// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

// Attention:
// - prefix the tutorial pages with 'tutorial_'
// - to add new pages you have to add them to:
//		- doc/tutorial/refman_overwrite.tex (pdf output)
//		- doc/doxygen/public/Tutorial_html.doxygen (html output)

//####################################### TERMS #######################################

/**

@page tutorial_ms_terms Mass spectrometry terms

 The following terms for MS-related data are used in this tutorial and the OpenMS class documentation:
 - raw data point @n
 	 An unprocessed data point as measured by the instrument.
 - peak @n
 	 Data point that is the result of some kind of peak detection algorithm. 
 	 Peaks are often referred to as @a sticks or @a centroided @a data as well.
 - spectrum @n
	 A mass spectrum containing raw data points (<i>raw spectrum</i>) or peaks (<i>peak spectrum</i>).

	@image html Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" 
	@image latex Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" width=10cm

 - map @n
   A collection of spectra generated by a HPLC-MS experiment. Depending on what kind of
   spectra are contained, we use the terms  <i>raw map</i> or <i>peak map</i>.
 - feature @n
   A chemical entity detected in an HPLC-MS experiment, typically a peptide.

	@image html Terms_Map.png "Peak map with a marked feature (red)" 
	@image latex Terms_Map.png "Peak map with a marked feature (red)" width=10cm
	
*/

//####################################### CONCEPT #######################################

/**

@page tutorial_concept OpenMS concepts
	
	This chapter covers some very basic concepts needed to understand OpenMS code.
	It describes OpenMS primitive types, namespaces, exceptions and
  important preprocessor macros.
	
@section concept_primitives Basic data types

  OpenMS has its own names for the C++ primitive types. The integer types of OpenMS
	are @a Int (int) and @a UInt (unsigned int). For floating point numbers @a Real (float) and
	@a DoubleReal (double) are used.

  These and more types are defined in @a OpenMS/CONCEPT/Types.h.

@section concept_namespace The OpenMS namespace

	The main classes of OpenMS are implemented in the namespace @a OpenMS. There are several
	sub-namespaces to the @a OpenMS namespace. The most important ones are:
	- @a OpenMS::Internal contains auxiliary classes that are typically used by only a few classes.
  - @a OpenMS::Constants contains nature constants.
  - @a OpenMS::Math contains math functions and classes.
  - @a OpenMS::Exception contains the OpenMS exceptions.
  
	There are several more namespaces. For a detailed description have a look at the
  class documentation.

@section concept_exceptions Exception handling in OpenMS

  All exceptions are defined in the namespace @a OpenMS::Exception. The Base class for all
  OpenMS exceptions is @a Base. This base class provides three members, which facilitate
  debugging OpenMS exceptions. It stores the source file, the line number and the function
  name where the exception occurred. All derived exceptions provide a constructor that takes
  at least these arguments. The following code snippet shows the handling of an index overflow:	
	@code
	  void someMethode(UInt index) throw (Exception::IndexOverflow)
		{
			if (index >= size())
			{
				throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, index, size()-1);
			}
			// do something
		};
	@endcode
	@a __FILE__ and @a __LINE__ are built-in preprocessor macros that hold the file name and line number.
	@a __PRETTY_FUNCTION__ is replaced by the GNU G++ compiler with the demangled name of 
	the current function. For other compilers it is defined as "<unknown>". The last two arguments
  are the invalid index and the maximum allowed index.

  The file name, line number and function name are very useful when debugging. However, OpenMS
	also implements its own exception handler which allows to turn each uncaught exception into a 
  segmentation fault. The mechanism allows developers to trace the source of an exception
  with a debugger. The only thing you have to do to use it is to set the environment variable
  @a OPENMS_DUMP_CORE.

@section concept_macros Condition macros
	
	In order to enforce invariants, the two preprocessor macros @a OPENMS_PRECONDITION and
  @a OPENMS_POSTCONDITION are provided. These macros are enabled if debug info is enabled 
  and optimization is disabled in @a configure. Otherwise they are removed by the preprocessor,
  so they won't cost any performance.

  The macros throw Exception::Precondition or Exception::Postcondition respectively if 
  the condition fails. The example from section @ref concept_exceptions could have been 
  implemented like that:
	@code
	  void someMethode(UInt index)
		{
			OPENMS_PRECONDITION(index < size(),"Precondition not met!");
			//do something
		};
	@endcode

*/

//####################################### DATASTRUCTURES #######################################

/**

@page tutorial_datastructures Auxiliary datastructures
	
	This section contains a short introduction to three datastructures you will
  definitely need when programming with OpenMS. The datastructures module of the
  class documentation contains many more classes, which are not mentioned here in
  detail.

@section datastructures_string The OpenMS string implementation

  The OpenMS string implementation @a OpenMS::String is based on the Qt string @a QString.
  In order to make the OpenMS string class more convenient, some methods have been
  implemented in addition to the QString methods.

	There is one property @a String inherits form @a QString that you should know about. 
  QString uses implicit sharing (copy-on-write), i.e. two copies of QString with
  the same content point to the same character array as long as you do not modify 
  one of the strings. This behavior allows to use pass-by-value instead of 
  pass-by-reference without loosing performance. A list of all Qt classes that use
  implicit sharing can be found in the Qt reference manual.

	@note There are many more OpenMS classes that are based on Qt classes, e.g. @a Data,
  @a DateTime and @a DataValue. Making yourself familiar with these Qt classes would be
  no harm!

@section datastructures_dposition D-dimensional coordinates

  Many OpenMS classes, especially the kernel classes, need to store some kind of 
  d-dimensional coordinates. The template class @a DPosition is used for that purpose.
	The interface of DPosition is pretty straight forward. The operator[] is used to
  access the coordinate of the different dimensions. The dimensionality is stored
  in the enum value @a DIMENSION. The following example shows how to print a DPosition
  to the standard output stream.

	First we need to include the header file for @a DPosition and @a iostream. Then we
  import all the OpenMS symbols to the scope with the @a using directive.
  @dontinclude Tutorial_DPosition.C
	@until namespace
  The first commands in the main method initialize a 2-dimensional @a DPosition :
	@until 47.11
	Finally we, print the content of the DPosition to the standard output stream:
	@until main
	
	The output of our first little OpenMS program is the following:
	@code
    Dimension 0: 8.15
    Dimension 1: 47.11
	@endcode
  
@section datastructures_drange D-dimensional ranges
	
  Another important datastructure we need to look at in detail is @a DRange. 
  It defines a d-dimensional, half-open interval through its two @a DPosition members.
  These members are accessed by the @a min and @a max methods and can be
  set by the @a setMin and @a setMax methods.

  DRange maintains the invariant that @a min is geometrically less or equal to @a max,
  i.e. @f$ min()[x] <= max()[x]' @f$. The following example demonstrates this behavior.

  This time we skip everything before the main method. In the main method we 
  create a range and assign values to @a min and @a max. Note that the the minimum
  value of the first dimension is larger than the maximum value.
  @dontinclude Tutorial_DRange.C
	@skip main
  @until setMax
  Then we print the content of @a range :
	@until main  
  
  The output is:
	@code
    min 0: 1
    max 0: 1
    min 1: 3
    max 1: 5
	@endcode
  As you can see, the minimum value of dimension one was adjusted in order
  to make the maximum of @a 1 conform with the invariant.

  @a DIntervalBase is the closed interval counterpart (and base class) of @a DRange.
  Another class derived from @a DIntervalBase is @a DBoundingBox. It also represents a
  closed interval, but differs in the methods. Please have a look at the class 
  documentation for details!

*/

//####################################### KERNEL #######################################

/**

@page tutorial_kernel The kernel classes
 
 The OpenMS kernel contains the datastructures that store the actual MS data, i.e. 
 raw data points, peaks, features, spectra, maps.

@section kernel_datapoints Raw data point, Peak, Feature, ...
	
	In general there are three types of data points: raw data points, peaks and picked peaks.
	Raw data points provide members to store position (mass-to-charge ratio, retention time, ...) and intensity.
	Peaks are derived form raw data points and add an interface to store meta information. 
	Picked peaks are derived from peaks and have additional members for peak shape information: 
	charge, width, signal-to-noise ratio and many more.
	
	The kernel data points exist in three versions: one-dimensional, two-dimensional and d-dimensional.

	@image html Kernel_DataPoints.png "Data structures for MS data points" 
	@image latex Kernel_DataPoints.png "Data structures for MS data points" width=14cm 

	@par one-dimensional data points
	The one-dimensional data points are most important, the two-dimensional and d-dimensional data points
	are needed rarely.
	The base class of the one-dimensional data points is @a RawDataPoint1D. It provides
	members to store the mass-to-charge ratio (@a getMZ and @a setMZ) and the intensity
	(@a getIntensity and @a setIntensity). @n
	@a Peak1D is derived from @a RawDataPoint1D and adds a interface for metadata (see @ref metadata_metainfo). @n
	@a PickedPeak1D is derived from @a Peak1D and adds information about the peak shape.

	@par two-dimensional data points
	The two-dimensional data points are needed when geometry algorithms are applied
	to the data points. A special case is the @a Feature class, which needs a two-dimensional
	position (m/z and RT). @n
	The base class of the two-dimensional data points is @a RawDataPoint2D. It provides
	the same interface as @a RawDataPoint1D and additional members for the retention time (@a getRT and @a setRT). @n
	@a Peak2D is derived from @a RawDataPoint2D and adds a interface form metadata. @n
	@a Feature is derived from @a Peak2D and adds information about the border of the feature, fitting quality
	and so on.
	
	@par d-dimensional data points
	The d-dimensional data points are needed only in special cases, e.g. in template classes that
	must operate on any number of dimensions. @n
	The base class of the d-dimensional data points is @a DRawDataPoint. The methods to access the position
	are @a getPosition and @a setPosition. @n
	Note that the one-dimensional and two-dimensional data points also have the methods 
	@a getPosition and @a setPosition. They are needed to able to write algorithms that can operate on 
	all data point types. It is however recommended not to use these members unless you really write such
	a generic algorithm.

@section kernel_spectra Spectra
	
	@par one-dimensional spectrum
	The most important container for raw data and peaks is @a MSSpectrum. It is a template
  class that takes the peak type as template argument. The default peak type is @a Peak1D. Possible other peak types
  are classes derived from @a RawDataPoint1D of classes providing the same interface. @n
	@a MSSpectrum is derived from two base classes: @a DSpectrum, a generic container for d-dimensional peak data, and from
  @a SpectrumSettings, a container for the meta data of a spectrum. Here MS data handling is explained, 
	@a SpectrumSettings is described in section @ref metadata_spectrum.

  @par d-dimensional spectrum
	The base class of @a MSSpectrum is @a DSpectrum. This class provides a generic container for d-dimensional data.
	One of the template arguments of @a DSpectrum is the Container the data is stored in. As container @p DPeakArray or a 
	container with the same interface is used. @a DPeakArray is vector of data points with a more convenient interface 
	for sorting of the data. @n
  The peak container can be accessed through the @a getContainer() method. For convenience, part of the container interface is
 	also provided by @a DSpectrum.

	In the following example program, a @a MSSpectrum is filled with peaks, sorted according to mass-to-charge
  ratio and a selection of peak positions is displayed.

	First we create a spectrum and insert peaks with descending mass-to-charge ratios: 
  @dontinclude Tutorial_MSSpectrum.C
	@skip main
	@until }
	Then we sort the peaks in according to ascending mass-to-charge ratio. As the method used for sorting is not wrapped by
	@a DSpectrum, we need to access the container to sort it.
	@until sort	
	Finally we print the peak positions of those peaks between 800 and 1000 Thomson. For printing all the peaks in the
  spectrum, we simply would have used the STL-conform methods @a begin() and @a end(). 
	@until main
	
	@par Typedefs
	For convenience the following type definitions are defined in @a OpenMS/KERNEL/StandardTypes.h.
	@code
	typedef MSSpectrum<Peak1D> PeakSpectrum;
  typedef MSSpectrum<RawDataPoint1D> RawSpectrum; 
	@endcode	

@section kernel_maps Maps 
	
	Although raw data maps, peak maps and feature maps are conceptually very similar. They are stored in different
  data types. For raw data and peak maps, the default container is @a MSExperiment, which is an array of @a MSSpectrum
	instances. Just as @a MSSpectrum it is a template class with the peak type as template parameter.

	In contrast the to raw data and peak maps, feature maps are no collection of one-dimensional spectra, but a set
  of two-dimensional @a Feature instances. The main datastructure for feature maps is called @a FeatureMap.

	Although @a MSExperiment and @a FeatureMap differ in the data they store, they also have things in common.
  Both stores meta data that is valid for the whole map, i.e. sample description and instrument description.
  This data is stored in the common base class @a ExperimentalSettings.

  @par MSExperiment
  The following figure shows the big picture of the kernel datastructures. @a MSExperiment is
  derived from @a ExperimentalSettings (meta data of the experiment) and from @a vector<MSSpectrum>.
  The one-dimensional spectrum @a MSSpectrum is derived from SpectrumSettings (meta data of a spectrum)
  and from @a DSpectrum<1>, which stores the actual peak data in a @a DPeakArray. @n
  Since DPeakArray is can store all types of peaks derived from @a RawDataPoint, all the data containers
  are template classes, that take the peak type as template argument. This is omitted in the diagram for
  simplicity.

  @image html Kernel.png "Overview of the main kernel datastructures" 
  @image latex Kernel.png "Overview of the main kernel datastructures" width=10cm

  @par Typedefs
  For convenience the following map types are defined in @a OpenMS/KERNEL/StandardTypes.h.
  @code
  typedef MSExperiment<Peak1D> PeakMap;
  typedef MSExperiment<RawDataPoint1D> RawMap; 
  @endcode

	The following example program, creates a @a MSExperiment containing four @a MSSpectrum instances.
	Then it iterates over an area and prints the peak positions in the area:

	First we create the spectra in a for-loop and set the retention time and MS level. Survey scans have 
  a MS level of 1, MS/MS scans would have a MS level of 2, and so on.
  @dontinclude Tutorial_MSExperiment.C
	@skip main
	@until setMSLevel
	Then we fill each spectrum with several peaks. As all spectra would have the same peaks otherwise,
  we add the retention time to the mass-to-charge ratio of each peak.
	@until creation
	Finally we iterate over the RT range (2,3) and the m/z range (603,802) and print the peak positions.
	@until }
	The output of this loop is:
	@code
	2 - 702
	2 - 802
	3 - 603
  3 - 703
	@endcode
	For printing all the peaks in the experiment, we could have used the STL-iterators of the 
  experiment to iterate over the spectra and the STL-iterators of the spectra to iterate over the peaks:
	@until main

  @par FeatureMap
	@a FeatureMap, the container for features, is simply a @a vector<Feature>. Additionally, it is 
	derived from @a ExperimentalSettings, to store the meta information. Just like @a MSExperiment
	it is a template class. It takes the feature type as template argument.
	
	The following example shows how to insert two features into a map and iterate over the features.
  @dontinclude Tutorial_FeatureMap.C
	@skip main
	@until end of main
	
  @par RangeManager  
	All peak and feature containers (@a DSpectrum, @a MSExperiment, @a FeatureMap) are also derived from @a RangeManager.
	This class facilitates the handling of MS data ranges. It allows to calculate and store both the position range 
	and the intensity range of the container.
	
	The following example shows the functionality of the class @a RangeManger using a @a FeatureMap.
	First a @a FeatureMap with two features is created, then the ranges are calulated and printed:
  @dontinclude Tutorial_RangeManager.C
	@skip main
	@until end of main
	
	The output of this program is:
	@code
	Int: 461.3 - 12213.5
	RT:  15 - 23.3
	m/z: 571.3 - 1311.3
	@endcode
	
*/

//####################################### METADATA #######################################

/**

@page tutorial_metadata How meta data is stored
 
 
@section metadata_metainfo MetaInfo

@section metadata_experiment Meta data of a map

@section metadata_spectrum Meta data of a spectrum

*/

//####################################### FORMAT #######################################

/**

@page tutorial_format File and DB access
 
 
@section format_file File adapter classes

	PeakFileOptions

@section format_db DB access

*/

//####################################### TRANSFORMATION #######################################

/**

@page tutorial_transformations Data reduction
 
 
@section transformations_pp Peak picking

@section transformations_ff Feature fionding

*/

//####################################### FILTERING #######################################

/**

@page tutorial_filtering Signal processing
 
 
@section filtering_baseline Baseline filters

@section filtering_smoothing Smoothing filters

*/

//####################################### ANALYSIS #######################################

/**

@page tutorial_analysis High level data analysis
 
 
@section analysis_mapmapping Map mapping

@section analysis_id Identification

*/
